# Wyciągnij producenta produktu
producer <- product %>% html_node(".product-info .info a strong") %>% html_text(trim = TRUE)
producers <- c(producers, producer)
# Wyciągnij ocenę produktu
rating_text <- product %>% html_node(".info .avg") %>% html_text(trim = TRUE)
rating <- stri_extract_first_regex(rating_text, "\\d+\\.\\d+")  # Wyciągnij wartość liczbową oceny
if (is.na(rating)) {
ratings <- c(ratings, NA)  # Jeśli brak oceny, dodajemy NA
} else {
ratings <- c(ratings, rating)
}
# Wyciągnij liczbę opinii lub tekst "Brak opinii"
reviews_text <- product %>% html_node(".info .comments") %>% html_text(trim = TRUE)
reviews_count <- stri_extract_first_regex(reviews_text, "\\d+")  # Wyciągnij liczbę opinii
if (is.na(reviews_count)) {
reviews_counts <- c(reviews_counts, "Brak opinii")  # Jeśli brak opinii, dodajemy tekst "Brak opinii"
} else {
reviews_counts <- c(reviews_counts, reviews_count)
}
# Wyciągnij pełny tekst z sekcji "price"
price_text <- product %>% html_node(".product_prices .price") %>% html_text(trim = TRUE)
# Zidentyfikuj cenę brutto, która znajduje się przed słowem "brutto"
brutto_price <- stri_extract_first_regex(price_text, "(\\d+,\\d+)\\s*zł\\s*brutto")
if (!is.na(brutto_price)) {
# Jeśli znaleźliśmy cenę brutto, usuwamy "brutto" i zamieniamy przecinek na kropkę
brutto_price <- stri_replace_all_fixed(brutto_price, "brutto", "")  # Usuń słowo "brutto"
brutto_price <- stri_replace_all_fixed(brutto_price, ",", ".")  # Zamień przecinek na kropkę
brutto_price <- stri_replace_all_fixed(brutto_price, " zł", "")  # Usuń spację i "zł"
prices <- c(prices, brutto_price)   # Dodaj cenę do listy
} else {
prices <- c(prices, NA)  # Jeśli cena brutto nie została znaleziona, dodajemy NA
}
# Opóźnienie przed przetwarzaniem kolejnego produktu
Sys.sleep(1)  # Sleep na 1 sekundę
}
# Liczba produktów, które chcesz wyciągnąć
num_products <- 5
# Tworzenie ramki danych dla tytułów, opisów i cen
data <- data.frame(
Title = titles[1:num_products],
Description = descriptions[1:num_products],  # Opisy bez "Przeczytaj dalej" i nadmiarowych znaków
Price = prices[1:num_products]  # Ceny
)
# Dodaj specyfikacje
data$Specifications <- specifications_list[1:num_products]
# Wyświetl dane
print(data)
# Przykłady jak można uzyskać dostęp do tytułów, opisów, cen i specyfikacji:
print(titles[2])  # Drugi tytuł
print(descriptions[1])  # Pierwszy opis (bez "Przeczytaj dalej")
print(prices[1])  # Cena pierwszego produktu
print(specifications_list[[1]])  # Specyfikacje dla 1. produktu
print(producers[1]) # Producent 1 kawy
print(ratings[2])  # Ocena 2. produktu
print(reviews_counts[2])  # Liczba opinii dla 2. produktu
# Uzyskanie 2. cechy specyfikacji dla 1. produktu
print(specifications_list[[1]][2])  # 2. element specyfikacji dla 1. produktu
library(rvest)
library(stringi)
# URL strony z kawami
url <- "https://www.konesso.pl/pol_m_Kawa_Rodzaj_Kawa-ziarnista-2160.html"
# Pobierz zawartość strony
webpage <- read_html(url)
# Wyciągnij wszystkie kontenery produktów
product_containers <- webpage %>% html_nodes("div.product_wrapper")
# Inicjalizowanie zmiennych do przechowywania danych
titles <- c()
descriptions <- c()
specifications_list <- list()
prices <- c()
producers <- c()
ratings <- c()
reviews_counts <- c()
# Iterujemy przez każdy kontener produktu
for (product in product_containers) {
# Wyciągnij tytuł produktu
title <- product %>% html_element("h5") %>% html_text(trim = TRUE)
titles <- c(titles, title)
# Wyciągnij opis produktu
description <- product %>% html_element(".product-desc") %>% html_text(trim = TRUE)
# Usuń frazę "Przeczytaj dalej"
description <- stri_replace_all_fixed(description, "Przeczytaj dalej", "")
# Usuń wszystkie znaki nowej linii \n
description <- stri_replace_all_fixed(description, "\n", " ")  # Zamień \n na pojedynczą spację
# Zastąp nadmiarowe spacje pojedynczą spacją
description <- stri_replace_all_regex(description, "\\s+", " ")
# Usuń nadmiarowe spacje z początku i końca
description <- stri_trim_both(description)
descriptions <- c(descriptions, description)
# Wyciągnij specyfikacje produktu
specifications <- product %>% html_elements(".traits_info ul li") %>% html_text(trim = TRUE)
# Usuń znaki nowej linii w specyfikacjach
specifications <- stri_replace_all_fixed(specifications, "\n", " ")  # Zamień \n na pojedynczą spację
# Zastąp nadmiarowe spacje pojedynczą spacją
specifications <- stri_replace_all_regex(specifications, "\\s+", " ")
# Usuń nadmiarowe spacje z początku i końca
specifications <- stri_trim_both(specifications)
# Dodaj specyfikacje produktu jako lista do listy głównej
specifications_list[[length(specifications_list) + 1]] <- specifications
# Wyciągnij producenta produktu
producer <- product %>% html_node(".product-info .info a strong") %>% html_text(trim = TRUE)
producers <- c(producers, producer)
# Wyciągnij ocenę produktu
rating_text <- product %>% html_node(".info .avg") %>% html_text(trim = TRUE)
rating <- stri_extract_first_regex(rating_text, "\\d+\\.\\d+")  # Wyciągnij wartość liczbową oceny
if (is.na(rating)) {
ratings <- c(ratings, NA)  # Jeśli brak oceny, dodajemy NA
} else {
ratings <- c(ratings, rating)
}
# Wyciągnij liczbę opinii lub tekst "Brak opinii"
reviews_text <- product %>% html_node(".info .comments") %>% html_text(trim = TRUE)
reviews_count <- stri_extract_first_regex(reviews_text, "\\d+")  # Wyciągnij liczbę opinii
if (is.na(reviews_count)) {
reviews_counts <- c(reviews_counts, "Brak opinii")  # Jeśli brak opinii, dodajemy tekst "Brak opinii"
} else {
reviews_counts <- c(reviews_counts, reviews_count)
}
# Wyciągnij pełny tekst z sekcji "price"
price_text <- product %>% html_node(".product_prices .price") %>% html_text(trim = TRUE)
# Zidentyfikuj cenę brutto, która znajduje się przed słowem "brutto"
brutto_price <- stri_extract_first_regex(price_text, "(\\d+,\\d+)\\s*zł\\s*brutto")
if (!is.na(brutto_price)) {
# Jeśli znaleźliśmy cenę brutto, usuwamy "brutto" i zamieniamy przecinek na kropkę
brutto_price <- stri_replace_all_fixed(brutto_price, "brutto", "")  # Usuń słowo "brutto"
brutto_price <- stri_replace_all_fixed(brutto_price, ",", ".")  # Zamień przecinek na kropkę
brutto_price <- stri_replace_all_fixed(brutto_price, " zł", "")  # Usuń spację i "zł"
prices <- c(prices, brutto_price)   # Dodaj cenę do listy
} else {
prices <- c(prices, NA)  # Jeśli cena brutto nie została znaleziona, dodajemy NA
}
# Opóźnienie przed przetwarzaniem kolejnego produktu
Sys.sleep(2)  # Sleep na 2 sekundy
}
# Liczba produktów, które chcesz wyciągnąć
num_products <- 5
# Tworzenie ramki danych dla tytułów, opisów i cen
data <- data.frame(
Title = titles[1:num_products],
Description = descriptions[1:num_products],  # Opisy bez "Przeczytaj dalej" i nadmiarowych znaków
Price = prices[1:num_products]  # Ceny
)
# Dodaj specyfikacje
data$Specifications <- specifications_list[1:num_products]
# Wyświetl dane
print(data)
# Przykłady jak można uzyskać dostęp do tytułów, opisów, cen i specyfikacji:
print(titles[2])  # Drugi tytuł
print(descriptions[1])  # Pierwszy opis (bez "Przeczytaj dalej")
print(prices[1])  # Cena pierwszego produktu
print(specifications_list[[1]])  # Specyfikacje dla 1. produktu
print(producers[1]) # Producent 1 kawy
print(ratings[2])  # Ocena 2. produktu
print(reviews_counts[2])  # Liczba opinii dla 2. produktu
# Uzyskanie 2. cechy specyfikacji dla 1. produktu
print(specifications_list[[1]][2])  # 2. element specyfikacji dla 1. produktu
library(rvest)
library(stringi)
# URL strony z kawami
url <- "https://www.konesso.pl/pol_m_Kawa_Rodzaj_Kawa-ziarnista-2160.html"
# Pobierz zawartość strony
webpage <- read_html(url)
# Wyciągnij wszystkie kontenery produktów
product_containers <- webpage %>% html_nodes("div.product_wrapper")
# Inicjalizowanie zmiennych do przechowywania danych
titles <- c()
descriptions <- c()
specifications_list <- list()
prices <- c()
producers <- c()
ratings <- c()
reviews_counts <- c()
# Iterujemy przez każdy kontener produktu
for (product in product_containers) {
# Wyciągnij tytuł produktu
title <- product %>% html_element("h5") %>% html_text(trim = TRUE)
titles <- c(titles, title)
# Wyciągnij opis produktu
description <- product %>% html_element(".product-desc") %>% html_text(trim = TRUE)
# Usuń frazę "Przeczytaj dalej"
description <- stri_replace_all_fixed(description, "Przeczytaj dalej", "")
# Usuń wszystkie znaki nowej linii \n
description <- stri_replace_all_fixed(description, "\n", " ")  # Zamień \n na pojedynczą spację
# Zastąp nadmiarowe spacje pojedynczą spacją
description <- stri_replace_all_regex(description, "\\s+", " ")
# Usuń nadmiarowe spacje z początku i końca
description <- stri_trim_both(description)
descriptions <- c(descriptions, description)
# Wyciągnij specyfikacje produktu
specifications <- product %>% html_elements(".traits_info ul li") %>% html_text(trim = TRUE)
# Usuń znaki nowej linii w specyfikacjach
specifications <- stri_replace_all_fixed(specifications, "\n", " ")  # Zamień \n na pojedynczą spację
# Zastąp nadmiarowe spacje pojedynczą spacją
specifications <- stri_replace_all_regex(specifications, "\\s+", " ")
# Usuń nadmiarowe spacje z początku i końca
specifications <- stri_trim_both(specifications)
# Dodaj specyfikacje produktu jako lista do listy głównej
specifications_list[[length(specifications_list) + 1]] <- specifications
# Wyciągnij producenta produktu
producer <- product %>% html_node(".product-info .info a strong") %>% html_text(trim = TRUE)
producers <- c(producers, producer)
# Wyciągnij ocenę produktu
rating_text <- product %>% html_node(".info .avg") %>% html_text(trim = TRUE)
rating <- stri_extract_first_regex(rating_text, "\\d+\\.\\d+")  # Wyciągnij wartość liczbową oceny
if (is.na(rating)) {
ratings <- c(ratings, NA)  # Jeśli brak oceny, dodajemy NA
} else {
ratings <- c(ratings, rating)
}
# Wyciągnij liczbę opinii lub tekst "Brak opinii"
reviews_text <- product %>% html_node(".info .comments") %>% html_text(trim = TRUE)
reviews_count <- stri_extract_first_regex(reviews_text, "\\d+")  # Wyciągnij liczbę opinii
if (is.na(reviews_count)) {
reviews_counts <- c(reviews_counts, "Brak opinii")  # Jeśli brak opinii, dodajemy tekst "Brak opinii"
} else {
reviews_counts <- c(reviews_counts, reviews_count)
}
# Wyciągnij pełny tekst z sekcji "price"
price_text <- product %>% html_node(".product_prices .price") %>% html_text(trim = TRUE)
# Zidentyfikuj cenę brutto, która znajduje się przed słowem "brutto"
brutto_price <- stri_extract_first_regex(price_text, "(\\d+,\\d+)\\s*zł\\s*brutto")
if (!is.na(brutto_price)) {
# Jeśli znaleźliśmy cenę brutto, usuwamy "brutto" i zamieniamy przecinek na kropkę
brutto_price <- stri_replace_all_fixed(brutto_price, "brutto", "")  # Usuń słowo "brutto"
brutto_price <- stri_replace_all_fixed(brutto_price, ",", ".")  # Zamień przecinek na kropkę
brutto_price <- stri_replace_all_fixed(brutto_price, " zł", "")  # Usuń spację i "zł"
prices <- c(prices, brutto_price)   # Dodaj cenę do listy
} else {
prices <- c(prices, NA)  # Jeśli cena brutto nie została znaleziona, dodajemy NA
}
# Opóźnienie przed przetwarzaniem kolejnego produktu
Sys.sleep(2)  # Sleep na 2 sekundy
}
# Liczba produktów, które chcesz wyciągnąć
num_products <- 5
# Tworzenie ramki danych dla tytułów, opisów i cen
data <- data.frame(
Title = titles[1:num_products],
Description = descriptions[1:num_products],  # Opisy bez "Przeczytaj dalej" i nadmiarowych znaków
Price = prices[1:num_products]  # Ceny
)
# Dodaj specyfikacje
data$Specifications <- specifications_list[1:num_products]
# Wyświetl dane
print(data)
# Przykłady jak można uzyskać dostęp do tytułów, opisów, cen i specyfikacji:
print(titles[2])  # Drugi tytuł
print(descriptions[1])  # Pierwszy opis (bez "Przeczytaj dalej")
print(prices[1])  # Cena pierwszego produktu
print(specifications_list[[1]])  # Specyfikacje dla 1. produktu
print(producers[1]) # Producent 1 kawy
print(ratings[2])  # Ocena 2. produktu
print(reviews_counts[2])  # Liczba opinii dla 2. produktu
# Uzyskanie 2. cechy specyfikacji dla 1. produktu
print(specifications_list[[1]][2])  # 2. element specyfikacji dla 1. produktu
library(httr)
library(rvest)
library(stringi)
# Pobranie zawartości strony
url <- "https://www.konesso.pl/pol_m_Kawa_Rodzaj_Kawa-ziarnista-2160.html"
response <- GET(url)
if (status_code(response) != 200) stop("Nie udało się pobrać zawartości strony")
webpage <- content(response, "text", encoding = "UTF-8") %>% read_html()
# Inicjalizacja list do przechowywania danych
product_containers <- webpage %>% html_nodes("div.product_wrapper")
titles <- c(); descriptions <- c(); specifications_list <- list()
prices <- c(); producers <- c(); ratings <- c(); reviews_counts <- c()
# Przetwarzanie danych produktów
for (product in product_containers) {
titles <- c(titles, product %>% html_element("h5") %>% html_text(trim = TRUE))
description <- product %>% html_element(".product-desc") %>% html_text(trim = TRUE)
description <- stri_replace_all_fixed(description, "Przeczytaj dalej", "") %>%
stri_replace_all_fixed("\n", " ") %>%
stri_replace_all_regex("\\s+", " ") %>%
stri_trim_both()
descriptions <- c(descriptions, description)
specifications <- product %>% html_elements(".traits_info ul li") %>% html_text(trim = TRUE) %>%
stri_replace_all_fixed("\n", " ") %>%
stri_replace_all_regex("\\s+", " ") %>%
stri_trim_both()
specifications_list[[length(specifications_list) + 1]] <- specifications
producers <- c(producers, product %>% html_node(".product-info .info a strong") %>% html_text(trim = TRUE))
rating_text <- product %>% html_node(".info .avg") %>% html_text(trim = TRUE)
rating <- stri_extract_first_regex(rating_text, "\\d+\\.\\d+")
ratings <- c(ratings, ifelse(is.na(rating), NA, rating))
reviews_text <- product %>% html_node(".info .comments") %>% html_text(trim = TRUE)
reviews_count <- stri_extract_first_regex(reviews_text, "\\d+")
reviews_counts <- c(reviews_counts, ifelse(is.na(reviews_count), "Brak opinii", reviews_count))
price_text <- product %>% html_node(".product_prices .price") %>% html_text(trim = TRUE)
brutto_price <- stri_extract_first_regex(price_text, "(\\d+,\\d+)\\s*zł\\s*brutto")
if (!is.na(brutto_price)) {
brutto_price <- brutto_price %>%
stri_replace_all_fixed("brutto", "") %>%
stri_replace_all_fixed(",", ".") %>%
stri_replace_all_fixed(" zł", "")
}
prices <- c(prices, brutto_price)
Sys.sleep(2)  # Uniknięcie zablokowania przez serwer
}
# Tworzenie ramki danych z pierwszych 5 produktów
num_products <- 5
data <- data.frame(
Title = titles[1:num_products],
Description = descriptions[1:num_products],
Price = prices[1:num_products]
)
data$Specifications <- specifications_list[1:num_products]
# Wyświetlanie wyników
print(data)
library(tidyverse)
library(stringi)
library(dplyr)
library(ggplot2)
df_kawa_filtered <- read.csv("kawa_filtered.csv")
library(tidyverse)
library(stringi)
library(dplyr)
library(ggplot2)
# Wczytanie pliku z odpowiednim separatorem
df_kawa <- read_csv2("kawa_with_bom_ok.csv", locale = locale(encoding = "UTF-8"))
# Funkcja, która przetwarza specyfikacje z jednej kawy
process_specifications <- function(specifications_text) {
specs <- stri_split_fixed(specifications_text, " | ", simplify = TRUE)
spec_names <- stri_extract(specs, regex = "^[^:]+(?=:)")
spec_values <- stri_extract(specs, regex = "(?<=:).+$")
spec_list <- setNames(spec_values, spec_names)
return(spec_list)
}
specifications_processed <- lapply(df_kawa$Specifications, process_specifications)
# Zamiana wyników na data frame
specifications_df <- bind_rows(specifications_processed)
# Dołączamy te kolumny do głównego data frame
df_kawa <- bind_cols(df_kawa, specifications_df)
# Usuwamy oryginalną kolumnę 'Specifications'
df_kawa <- df_kawa %>% select(-Specifications)
# Zidentyfikujmy liczbę nie-NA wartości w każdej kolumnie
non_na_counts <- colSums(!is.na(df_kawa))
# Filtrujemy kolumny, w których liczba nie-NA wartości jest większa lub równa 1000
df_kawa_filtered <- df_kawa[, non_na_counts >= 1000]
# Zmiana nazw kolumn na polski, podkreślenia zamiast spacji i myślników
colnames(df_kawa_filtered) <- c(
"Tytuł", "Opis", "Cena", "Producent", "Ocena", "Liczba_opinii",
"Skład", "Stopień_palenia", "Zawartość_kofeiny", "Rodzaj", "Palarnia",
"Przeznaczenie", "Opakowanie", "Sposób_przygotowania", "Crema", "Wyczuwalne_smaki",
"Intensywność_smaku", "Gorycz", "Kwasowość", "Słodycz",
"Pochodzenie_ziaren", "Blend_czy_Single", "Polecana_do", "Kawa_Specialty"
)
# Zamiana spacji oraz myślników na podkreślenia w nazwach kolumn
colnames(df_kawa_filtered) <- gsub(" |-", "_", colnames(df_kawa_filtered))
# Funkcja do konwersji wartości na skalę 1/5 do 5/5
convert_to_5_scale <- function(value) {
# Usunięcie spacji i zamiana tekstów na odpowiednią skalę
value <- gsub(" ", "", value)  # Usuwamy białe znaki
if (grepl("Delikatna", value)) {
return(0.2)
} else if (grepl("Średnia", value)) {
return(0.6)
} else if (grepl("Mocna", value)) {
return(1)
}
# Dla wartości numerycznych jak "2/5", "3/5"
if (grepl("^\\d+/\\d+$", value)) {
return(as.numeric(stri_extract(value, regex = "^\\d+")) / as.numeric(stri_extract(value, regex = "(?<=/).*")))
}
# Dla wartości numerycznych jak "1", "2", "3", "4", "5"
if (grepl("^\\d+$", value)) {
if (as.numeric(value) == 1) {
return(0.2)
} else if (as.numeric(value) == 2) {
return(0.4)
} else if (as.numeric(value) == 3) {
return(0.6)
} else if (as.numeric(value) == 4) {
return(0.8)
} else {
return(1)
}
}
return(NA)
}
# Zastosowanie funkcji do przekształcenia na skalę 1/5 do 5/5 w odpowiednich kolumnach
df_kawa_filtered$Gorycz <- sapply(df_kawa_filtered$Gorycz, convert_to_5_scale)
df_kawa_filtered$Kwasowość <- sapply(df_kawa_filtered$Kwasowość, convert_to_5_scale)
df_kawa_filtered$Słodycz <- sapply(df_kawa_filtered$Słodycz, convert_to_5_scale)
df_kawa_filtered$Intensywność_smaku <- sapply(df_kawa_filtered$Intensywność_smaku, convert_to_5_scale)
# Usuwamy atrybuty "names" za pomocą unname()
df_kawa_filtered$Gorycz <- unname(df_kawa_filtered$Gorycz)
df_kawa_filtered$Kwasowość <- unname(df_kawa_filtered$Kwasowość)
df_kawa_filtered$Słodycz <- unname(df_kawa_filtered$Słodycz)
df_kawa_filtered$Intensywność_smaku <- unname(df_kawa_filtered$Intensywność_smaku)
# Dzielimy cenę przez 100 i formatowanie jej z dwoma miejscami po przecinku
df_kawa_filtered$Cena <- as.numeric(df_kawa_filtered$Cena) / 100
# Jeśli chcesz, aby wartości były dokładnie z dwoma miejscami po przecinku, użyj formatowania
df_kawa_filtered$Cena <- format(df_kawa_filtered$Cena, nsmall = 2)
# Konwersja kolumny Ocena z typu chr na num (float)
df_kawa_filtered$Ocena <- as.numeric(df_kawa_filtered$Ocena)
# Sprawdzamy wynik po formatowaniu
# Sprawdzamy wynikowy data frame
str(df_kawa_filtered)
df_kawa_filtered$Opakowanie <- ifelse(df_kawa_filtered$Opakowanie == " 1000",
" 1000g",
df_kawa_filtered$Opakowanie)
table(df_kawa_filtered$Opakowanie)
# Save the dataframe to a CSV file
write.csv(df_kawa_filtered, "kawa_filtered.csv", row.names = FALSE)
library(tidyverse)
library(stringi)
library(dplyr)
library(ggplot2)
df_kawa_filtered <- read.csv("kawa_filtered.csv")
str(df_kawa_filtered)
#PRICE RANGE ANALYSIS
# Step 1: Standardize and clean the 'Opakowanie' column
df_kawa_filtered$Weight_g <- as.numeric(gsub("[^0-9]", "", df_kawa_filtered$Opakowanie))
# Handle specific cases
df_kawa_filtered$Weight_g[grepl("Szklana butelka", df_kawa_filtered$Opakowanie)] <- NA  # Non-numeric, set to NA
# Step 2: Clean 'Cena' and convert to numeric
df_kawa_filtered$Cena <- as.numeric(gsub(",", ".", gsub("\\s", "", df_kawa_filtered$Cena)))
# Step 3: Calculate "Price per Gram", excluding rows with NA in Weight_g or Cena
df_kawa_filtered <- df_kawa_filtered[!is.na(df_kawa_filtered$Weight_g) & !is.na(df_kawa_filtered$Cena), ]
df_kawa_filtered$Price_per_Gram <- df_kawa_filtered$Cena / df_kawa_filtered$Weight_g
# Step 4: Group coffees into price ranges
df_kawa_filtered$Price_Range <- cut(
df_kawa_filtered$Price_per_Gram,
breaks = c(0, 0.05, 0.1, 0.2, Inf),
labels = c("Budget (< 0.05)", "Mid-range (0.05 - 0.1)", "Premium (0.1 - 0.2)", "Luxury (> 0.2)"),
right = FALSE
)
# Step 5: Visualize the distribution of products in each price range
library(ggplot2)
ggplot(df_kawa_filtered, aes(x = Price_Range)) +
geom_bar(fill = "steelblue", color = "black") +
labs(
title = "Distribution of Products by Price Range",
x = "Price Range (PLN per Gram)",
y = "Number of Products"
) +
theme_minimal()
#ADDING ADJUSTED RATINGS COLUMN
# Step 1: Handle NA values in 'Ocena' and 'Liczba_opinii'
df_kawa_filtered$Ocena[is.na(df_kawa_filtered$Ocena)] <- 0
df_kawa_filtered$Liczba_opinii[is.na(df_kawa_filtered$Liczba_opinii)] <- 0
# Step 2: Calculate the "Adjusted Rating"
#- Multiplying the Ocena by the square root of the Liczba_opinii to give more weight to well-reviewed products.
df_kawa_filtered$Adjusted_Rating <- df_kawa_filtered$Ocena * sqrt(df_kawa_filtered$Liczba_opinii)
# Step 3: Preview the result
head(df_kawa_filtered[, c("Ocena", "Liczba_opinii", "Adjusted_Rating")])
#ANALYSING PRODUCERS, NUM OF OPINIONS AND RATINGS
# Step 1: Calculate average number of ratings and adjusted ratings for each producer
producer_analysis <- df_kawa_filtered %>%
group_by(Producent) %>%
summarise(
Avg_Num_Ratings = mean(Liczba_opinii, na.rm = TRUE),
Avg_Adjusted_Rating = mean(Adjusted_Rating, na.rm = TRUE),
Count_Products = n()
) %>%
arrange(desc(Avg_Num_Ratings))  # Sort by popularity
# Step 2: Top producers by average number of ratings
top_popular_producers <- producer_analysis %>%
top_n(10, Avg_Num_Ratings)
# Step 3: Top producers by adjusted rating
top_adjusted_rating_producers <- producer_analysis %>%
top_n(10, Avg_Adjusted_Rating)
# Step 4: Visualize popularity
library(ggplot2)
# Bar chart for average number of ratings
ggplot(top_popular_producers, aes(x = reorder(Producent, Avg_Num_Ratings), y = Avg_Num_Ratings)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() +
labs(
title = "Top Producers by Average Number of Ratings",
x = "Producer",
y = "Average Number of Ratings"
) +
theme_minimal()
# Bar chart for average adjusted rating
ggplot(top_adjusted_rating_producers, aes(x = reorder(Producent, Avg_Adjusted_Rating), y = Avg_Adjusted_Rating)) +
geom_bar(stat = "identity", fill = "darkgreen") +
coord_flip() +
labs(
title = "Top Producers by Average Adjusted Rating",
x = "Producer",
y = "Average Adjusted Rating"
) +
theme_minimal()
#CORELATION ANALYSIS OF COFFEE SPECIFICATION AND ADJUSTED RATING
# Step 1: Prepare data for correlation analysis
correlation_data <- df_kawa_filtered %>%
select(Kwasowość, Gorycz, Słodycz, Intensywność_smaku, Adjusted_Rating) %>%
na.omit()  # Remove rows with NA values
# Step 2: Compute the correlation matrix
correlation_matrix <- cor(correlation_data)
# Step 3: Visualize the correlation matrix
library(ggplot2)
library(reshape2)
# Convert matrix to long format for ggplot
correlation_long <- melt(correlation_matrix)
# Plot heatmap
ggplot(correlation_long, aes(Var1, Var2, fill = value)) +
geom_tile(color = "white") +
scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0, limit = c(-1, 1), space = "Lab", name = "Correlation") +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
axis.text = element_text(size = 10)
) +
labs(
title = "Correlation Heatmap",
x = "Specifications",
y = "Specifications"
)
###
